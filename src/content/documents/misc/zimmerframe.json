{
  "title": "zimmerframe",
  "metadata": {},
  "atAGlance": "```ts\nimport { walk } from 'zimmerframe';\nimport { parse } from 'acorn';\nimport { Node } from 'estree';\n\nconst program = parse(`\nlet message = 'hello';\nconsole.log(message);\n\nif (true) {\n  let answer = 42;\n  console.log(answer);\n}\n`);\n\n// You can pass in arbitrary state\nconst state = {\n  declarations: [],\n  depth: 0\n};\n\nconst transformed = walk(program as Node, state, {\n  _(node, { state, next }) {\n    // the `_` visitor is 'universal' — if provided,\n    // it will run for every node, before deferring\n    // to specialised visitors. you can pass a new\n    // `state` object to `next`\n    next({ ...state, answer: 42 });\n  },\n  VariableDeclarator(node, { state }) {\n    // `state` is passed into each visitor\n    if (node.id.type === 'Identifier') {\n      state.declarations.push({\n        depth: state.depth,\n        name: node.id.name\n      });\n    }\n  },\n  BlockStatement(node, { state, next, stop }) {\n    // you must call `next()` or `next(childState)`\n    // to visit child nodes\n    console.log('entering BlockStatement');\n    next({ ...state, depth: state.depth + 1 });\n    console.log('leaving BlockStatement');\n  },\n  Literal(node) {\n    // if you return something, it will replace\n    // the current node\n    if (node.value === 'hello') {\n      return {\n        ...node,\n        value: 'goodbye'\n      };\n    }\n  },\n  IfStatement(node, { visit }) {\n    // normally, returning a value will halt\n    // traversal into child nodes. you can\n    // transform children with the current\n    // visitors using `visit(node, state?)`\n    if (node.test.type === 'Literal' && node.test.value === true) {\n      return visit(node.consequent);\n    }\n  }\n});\n```\n\nThe `transformed` AST would look like this:\n\n```js\nlet message = 'goodbye';\nconsole.log(message);\n\n{\n  let answer = 42;\n  console.log(answer);\n}\n```",
  "commonKnowledge": "### Types\n\nThe type of `node` in each visitor is inferred from the visitor's name. For example:\n\n```ts\nwalk(ast as estree.Node, state, {\n  ArrowFunctionExpression(node) {\n    // `node` is of type estree.ArrowFunctionExpression\n  }\n});\n```\n\nFor this to work, the first argument should be casted to an union of all the types you plan to visit.\n\nYou can import types from 'zimmerframe':\n\n```ts\nimport {\n  walk,\n  type Visitor,\n  type Visitors,\n  type Context\n} from 'zimmerframe';\nimport type { Node } from 'estree';\n\ninterface State {...}\n\nconst node: Node = {...};\nconst state: State = {...};\nconst visitors: Visitors<Node, State> =  {...}\n\nwalk(node, state, visitors);\n```\n\n### Context\n\nEach visitor receives a second argument, `context`, which is an object with the following properties and methods:\n\n- `next(state?: State): void` — a function that allows you to control when child nodes are visited, and which state they are visited with. If child visitors transform their inputs, this will return the transformed node (if not, returns `undefined`)\n- `path: Node[]` — an array of parent nodes. For example, to get the root node you would do `path.at(0)`; to get the current node's immediate parent you would do `path.at(-1)`\n- `state: State` — an object of the same type as the second argument to `walk`. Visitors can pass new state objects to their children with `next(childState)` or `visit(node, childState)`\n- `stop(): void` — prevents any subsequent traversal\n- `visit(node: Node, state?: State): Node` — returns the result of visiting `node` with the current set of visitors. If no `state` is provided, children will inherit the current state\n\n### Immutability\n\nASTs are regarded as immutable. If you return a transformed node from a visitor, then all parents of the node will be replaced with clones, but unchanged subtrees will reuse the existing nodes.\n\nFor example in this case, no transformation takes place, meaning that the returned value is identical to the original AST:\n\n```js\nconst transformed = walk(original, state, {\n  Literal(node) {\n    console.log(node.value);\n  }\n});\n\ntransformed === original; // true\n```\n\nIn this case, however, we replace one of the nodes:\n\n```js\nconst original = {\n  type: 'BinaryExpression',\n  operator: '+',\n  left: {\n    type: 'Identifier',\n    name: 'foo'\n  },\n  right: {\n    type: 'Identifier',\n    name: 'bar'\n  }\n};\n\nconst transformed = walk(original, state, {\n  Identifier(node) {\n    if (node.name === 'bar') {\n      return { ...node, name: 'baz' };\n    }\n  }\n});\n\ntransformed === original; // false, the BinaryExpression node is cloned\ntransformed.left === original.left; // true, we can safely reuse this node\n```\n\nThis makes it very easy to transform parts of your AST without incurring the performance and memory overhead of cloning the entire thing, and without the footgun of mutating it in place.\n\n### License\n\nMIT",
  "secretKnowledge": "",
  "seeAlso": [],
  "rawContent": "# zimmerframe\n\nA tool for walking.\n\nSpecifically, it's a tool for walking an abstract syntax tree (AST), where every node is an object with a `type: string`. This includes [ESTree](https://github.com/estree/estree) nodes, such as you might generate with [Acorn](https://github.com/acornjs/acorn) or [Meriyah](https://github.com/meriyah/meriyah), but also includes things like [CSSTree](https://github.com/csstree/csstree) or an arbitrary AST of your own devising.\n\n## Usage\n\n```ts\nimport { walk } from 'zimmerframe';\nimport { parse } from 'acorn';\nimport { Node } from 'estree';\n\nconst program = parse(`\nlet message = 'hello';\nconsole.log(message);\n\nif (true) {\n  let answer = 42;\n  console.log(answer);\n}\n`);\n\n// You can pass in arbitrary state\nconst state = {\n  declarations: [],\n  depth: 0\n};\n\nconst transformed = walk(program as Node, state, {\n  _(node, { state, next }) {\n    // the `_` visitor is 'universal' — if provided,\n    // it will run for every node, before deferring\n    // to specialised visitors. you can pass a new\n    // `state` object to `next`\n    next({ ...state, answer: 42 });\n  },\n  VariableDeclarator(node, { state }) {\n    // `state` is passed into each visitor\n    if (node.id.type === 'Identifier') {\n      state.declarations.push({\n        depth: state.depth,\n        name: node.id.name\n      });\n    }\n  },\n  BlockStatement(node, { state, next, stop }) {\n    // you must call `next()` or `next(childState)`\n    // to visit child nodes\n    console.log('entering BlockStatement');\n    next({ ...state, depth: state.depth + 1 });\n    console.log('leaving BlockStatement');\n  },\n  Literal(node) {\n    // if you return something, it will replace\n    // the current node\n    if (node.value === 'hello') {\n      return {\n        ...node,\n        value: 'goodbye'\n      };\n    }\n  },\n  IfStatement(node, { visit }) {\n    // normally, returning a value will halt\n    // traversal into child nodes. you can\n    // transform children with the current\n    // visitors using `visit(node, state?)`\n    if (node.test.type === 'Literal' && node.test.value === true) {\n      return visit(node.consequent);\n    }\n  }\n});\n```\n\nThe `transformed` AST would look like this:\n\n```js\nlet message = 'goodbye';\nconsole.log(message);\n\n{\n  let answer = 42;\n  console.log(answer);\n}\n```\n\n## Types\n\nThe type of `node` in each visitor is inferred from the visitor's name. For example:\n\n```ts\nwalk(ast as estree.Node, state, {\n  ArrowFunctionExpression(node) {\n    // `node` is of type estree.ArrowFunctionExpression\n  }\n});\n```\n\nFor this to work, the first argument should be casted to an union of all the types you plan to visit.\n\nYou can import types from 'zimmerframe':\n\n```ts\nimport {\n  walk,\n  type Visitor,\n  type Visitors,\n  type Context\n} from 'zimmerframe';\nimport type { Node } from 'estree';\n\ninterface State {...}\n\nconst node: Node = {...};\nconst state: State = {...};\nconst visitors: Visitors<Node, State> =  {...}\n\nwalk(node, state, visitors);\n```\n\n## Context\n\nEach visitor receives a second argument, `context`, which is an object with the following properties and methods:\n\n- `next(state?: State): void` — a function that allows you to control when child nodes are visited, and which state they are visited with. If child visitors transform their inputs, this will return the transformed node (if not, returns `undefined`)\n- `path: Node[]` — an array of parent nodes. For example, to get the root node you would do `path.at(0)`; to get the current node's immediate parent you would do `path.at(-1)`\n- `state: State` — an object of the same type as the second argument to `walk`. Visitors can pass new state objects to their children with `next(childState)` or `visit(node, childState)`\n- `stop(): void` — prevents any subsequent traversal\n- `visit(node: Node, state?: State): Node` — returns the result of visiting `node` with the current set of visitors. If no `state` is provided, children will inherit the current state\n\n## Immutability\n\nASTs are regarded as immutable. If you return a transformed node from a visitor, then all parents of the node will be replaced with clones, but unchanged subtrees will reuse the existing nodes.\n\nFor example in this case, no transformation takes place, meaning that the returned value is identical to the original AST:\n\n```js\nconst transformed = walk(original, state, {\n  Literal(node) {\n    console.log(node.value);\n  }\n});\n\ntransformed === original; // true\n```\n\nIn this case, however, we replace one of the nodes:\n\n```js\nconst original = {\n  type: 'BinaryExpression',\n  operator: '+',\n  left: {\n    type: 'Identifier',\n    name: 'foo'\n  },\n  right: {\n    type: 'Identifier',\n    name: 'bar'\n  }\n};\n\nconst transformed = walk(original, state, {\n  Identifier(node) {\n    if (node.name === 'bar') {\n      return { ...node, name: 'baz' };\n    }\n  }\n});\n\ntransformed === original; // false, the BinaryExpression node is cloned\ntransformed.left === original.left; // true, we can safely reuse this node\n```\n\nThis makes it very easy to transform parts of your AST without incurring the performance and memory overhead of cloning the entire thing, and without the footgun of mutating it in place.\n\n## License\n\nMIT\n",
  "sourcePath": "dnd-tracker/node_modules/zimmerframe/README.md",
  "slug": "zimmerframe",
  "category": "misc"
}