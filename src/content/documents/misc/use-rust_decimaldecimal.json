{
  "title": "use rust_decimal::Decimal;",
  "metadata": {},
  "atAGlance": "",
  "commonKnowledge": "",
  "secretKnowledge": "",
  "seeAlso": [],
  "rawContent": "\nA Decimal number implementation written in pure Rust suitable for financial calculations that require significant\nintegral and fractional digits with no round-off errors.\n\nThe binary representation consists of a 96 bit integer number, a scaling factor used to specify the decimal fraction and\na 1 bit sign. Because of this representation, trailing zeros are preserved and may be exposed when in string form. These\ncan be truncated using the `normalize` or `round_dp` functions.\n\n## Installing\n\n```sh\n$ cargo add rust_decimal\n```\n\nAlternatively, you can edit your `Cargo.toml` directly and run `cargo update`:\n\n```toml\n[dependencies]\nrust_decimal = \"1.40\"\n```\n\nTo enable macro support, you can enable the `macros` feature:\n\n```sh\n$ cargo add rust_decimal --features macros\n```\n\n## Usage\n\nDecimal numbers can be created in a few distinct ways. The easiest and most efficient method of creating a Decimal is to\nuse the macro:\n\n```rust\n# use rust_decimal::Decimal;\n# use rust_decimal_macros::dec;\n\n// Import via use rust_decimal_macros or use the `macros` feature to import at the crate level\n// `use rust_decimal_macros::dec;`\n// or\n// `use rust_decimal::dec;`\n\nlet number = dec!(-1.23) + dec!(3.45);\nassert_eq!(number, dec!(2.22));\nassert_eq!(number.to_string(), \"2.22\");\n```\n\nAlternatively you can also use one of the Decimal number convenience\nfunctions ([see the docs](https://docs.rs/rust_decimal/) for more details):\n\n```rust\n# use rust_decimal::Decimal;\n# use rust_decimal_macros::dec;\n\n// Using the prelude can help importing trait based functions (e.g. core::str::FromStr).\nuse rust_decimal::prelude::*;\n\n// Using an integer followed by the decimal points\nlet scaled = Decimal::new(202, 2);\nassert_eq!(\"2.02\", scaled.to_string());\n\n// From a 128 bit integer\nlet balance = Decimal::from_i128_with_scale(5_897_932_384_626_433_832, 2);\nassert_eq!(\"58979323846264338.32\", balance.to_string());\n\n// From a string representation\nlet from_string = Decimal::from_str(\"2.02\").unwrap();\nassert_eq!(\"2.02\", from_string.to_string());\n\n// From a string representation in a different base\nlet from_string_base16 = Decimal::from_str_radix(\"ffff\", 16).unwrap();\nassert_eq!(\"65535\", from_string_base16.to_string());\n\n// From scientific notation\nlet sci = Decimal::from_scientific(\"9.7e-7\").unwrap();\nassert_eq!(\"0.00000097\", sci.to_string());\n\n// Using the `Into` trait\nlet my_int: Decimal = 3_i32.into();\nassert_eq!(\"3\", my_int.to_string());\n\n// Using the raw decimal representation\nlet pi = Decimal::from_parts(1_102_470_952, 185_874_565, 1_703_060_790, false, 28);\nassert_eq!(\"3.1415926535897932384626433832\", pi.to_string());\n\n// If the `macros` feature is enabled, it also allows for the `dec!` macro\nlet amount = dec!(25.12);\nassert_eq!(\"25.12\", amount.to_string());\n```\n\nOnce you have instantiated your `Decimal` number you can perform calculations with it just like any other number:\n\n```rust\n# use rust_decimal::Decimal;\n# use rust_decimal_macros::dec;\n\nuse rust_decimal::prelude::*; // Includes the `dec` macro when feature specified\n\nlet amount = dec!(25.12);\nlet tax_percentage = dec!(0.085);\nlet total = amount + (amount * tax_percentage).round_dp(2);\nassert_eq!(total, dec!(27.26));\n```\n\n## Features\n\n**Behavior / Functionality**\n\n* [borsh](#borsh)\n* [c-repr](#c-repr)\n* [legacy-ops](#legacy-ops)\n* [macros](#macros)\n* [maths](#maths)\n* [ndarray](#ndarray)\n* [rkyv](#rkyv)\n* [rocket-traits](#rocket-traits)\n* [rust-fuzz](#rust-fuzz)\n* [std](#std)\n\n**Database**\n\n* [db-postgres](#db-postgres)\n* [db-tokio-postgres](#db-tokio-postgres)\n* [db-diesel-postgres](#db-diesel-postgres)\n* [db-diesel-mysql](#db-diesel-mysql)\n\n**Serde**\n\n* [serde-float](#serde-float)\n* [serde-str](#serde-str)\n* [serde-arbitrary-precision](#serde-arbitrary-precision)\n* [serde-with-float](#serde-with-float)\n* [serde-with-str](#serde-with-str)\n* [serde-with-arbitrary-precision](#serde-with-arbitrary-precision)\n\n### `align16`\n\nForces `Decimal`'s alignment to 16 bytes (128 bits). This is identical to `u128` and `i128`'s alignment on x86 platforms.\n\n### `borsh`\n\nEnables [Borsh](https://borsh.io/) serialization for `Decimal`.\n\n### `c-repr`\n\nForces `Decimal` to use `[repr(C)]`.\n\n### `db-postgres`\n\nEnables a PostgreSQL communication module. It allows for reading and writing the `Decimal`\ntype by transparently serializing/deserializing into the `NUMERIC` data type within PostgreSQL.\n\n### `db-tokio-postgres`\n\nEnables the tokio postgres module allowing for async communication with PostgreSQL.\n\n### `db-diesel-postgres`\n\nEnable [`diesel`](https://diesel.rs) PostgreSQL support.\n\n### `db-diesel-mysql`\n\nEnable [`diesel`](https://diesel.rs) MySQL support.\n\n### `legacy-ops`\n\n**Warning:** This is deprecated and will be removed from a future versions.\n\nAs of `1.10` the algorithms used to perform basic operations have changed which has benefits of significant speed\nimprovements.\nTo maintain backwards compatibility this can be opted out of by enabling the `legacy-ops` feature.\n\n### `macros`\n\nThe `macros` feature enables a compile time macro `dec` to be available at both the crate root, and via prelude.\n\nThis parses the input at compile time and converts it to an optimized `Decimal` representation. Invalid inputs will\ncause a compile time error.\n\nAny Rust number format is supported, including scientific notation and alternate bases.\n\n```rust\n# use rust_decimal::Decimal;\n# use rust_decimal_macros::dec;\n# use serde::{Serialize, Deserialize};\n# #[cfg(features = \"macros\")]\nuse rust_decimal::prelude::*;\n\nassert_eq!(dec!(1.23), Decimal::new(123, 2));\n```\n\n### `maths`\n\nThe `maths` feature enables additional complex mathematical functions such as `pow`, `ln`, `enf`, `exp` etc.\nDocumentation detailing the additional functions can be found on the\n[`MathematicalOps`](https://docs.rs/rust_decimal/latest/rust_decimal/trait.MathematicalOps.html) trait.\n\nPlease note that `ln` and `log10` will panic on invalid input with `checked_ln` and `checked_log10` the preferred\nfunctions\nto curb against this. When the `maths` feature was first developed the library would instead return `0` on invalid\ninput. To re-enable this\nnon-panicking behavior, please use the feature: `maths-nopanic`.\n\n### `ndarray`\n\nEnables arithmetic operations using [`ndarray`](https://github.com/rust-ndarray/ndarray) on arrays of `Decimal`.\n\n### `proptest`\n\nEnables a [`proptest`](https://github.com/proptest-rs/proptest) strategy to generate values for Rust Decimal.\n\n### `rand`\n\nImplements `rand::distributions::Distribution<Decimal>` to allow the creation of random instances.\n\nNote: When using `rand::Rng` trait to generate a decimal between a range of two other decimals, the scale of the\nrandomly-generated\ndecimal will be the same as the scale of the input decimals (or, if the inputs have different scales, the higher of the\ntwo).\n\n### `rkyv`\n\nEnables [rkyv](https://github.com/rkyv/rkyv) serialization for `Decimal`. In order to avoid breaking changes, this is\ncurrently locked at version `0.7`.\n\nSupports rkyv's safe API when the `rkyv-safe` feature is enabled as well.\n\nIf `rkyv` support for versions `0.8` of greater is desired, `rkyv`'\ns [remote derives](https://rkyv.org/derive-macro-features/remote-derive.html) should be used instead. See\n`examples/rkyv-remote`.\n\n### `rocket-traits`\n\nEnable support for Rocket forms by implementing the `FromFormField` trait.\n\n### `rust-fuzz`\n\nEnable `rust-fuzz` support by implementing the `Arbitrary` trait.\n\n### `serde-float`\n\n> **Note:** This feature applies float serialization/deserialization rules as the default method for handling `Decimal`\n> numbers.\n> See also the `serde-with-*` features for greater flexibility.\n\nEnable this so that JSON serialization of `Decimal` types are sent as a float instead of a string (default).\n\ne.g. with this turned on, JSON serialization would output:\n\n```json\n{\n  \"value\": 1.234\n}\n```\n\n### `serde-str`\n\n> **Note:** This feature applies string serialization/deserialization rules as the default method for handling `Decimal`\n> numbers.\n> See also the `serde-with-*` features for greater flexibility.\n\nThis is typically useful for `bincode` or `csv` like implementations.\n\nSince `bincode` does not specify type information, we need to ensure that a type hint is provided in order to\ncorrectly be able to deserialize. Enabling this feature on its own will force deserialization to use `deserialize_str`\ninstead of `deserialize_any`.\n\nIf, for some reason, you also have `serde-float` enabled then this will use `deserialize_f64` as a type hint. Because\nconverting to `f64` _loses_ precision, it's highly recommended that you do NOT enable this feature when working with\n`bincode`. That being said, this will only use 8 bytes so is slightly more efficient in terms of storage size.\n\n### `serde-arbitrary-precision`\n\n> **Note:** This feature applies arbitrary serialization/deserialization rules as the default method for\n> handling `Decimal` numbers.\n> See also the `serde-with-*` features for greater flexibility.\n\nThis is used primarily with `serde_json` and consequently adds it as a \"weak dependency\". This supports the\n`arbitrary_precision` feature inside `serde_json` when parsing decimals.\n\nThis is recommended when parsing \"float\" looking data as it will prevent data loss.\n\nPlease note, this currently serializes numbers in a float like format by default, which can be an unexpected\nconsequence. For greater\ncontrol over the serialization format, please use the `serde-with-arbitrary-precision` feature.\n\n### `serde-with-float`\n\nEnable this to access the module for serializing `Decimal` types to a float. This can be used in `struct` definitions\nlike so:\n\n```rust\n# use rust_decimal::Decimal;\n# use rust_decimal_macros::dec;\n# use serde::{Serialize, Deserialize};\n# #[cfg(features = \"serde-with-float\")]\n#[derive(Serialize, Deserialize)]\npub struct FloatExample {\n    #[serde(with = \"rust_decimal::serde::float\")]\n    value: Decimal,\n}\n```\n\n```rust\n# use rust_decimal::Decimal;\n# use rust_decimal_macros::dec;\n# use serde::{Serialize, Deserialize};\n# #[cfg(features = \"serde-with-float\")]\n#[derive(Serialize, Deserialize)]\npub struct OptionFloatExample {\n    #[serde(with = \"rust_decimal::serde::float_option\")]\n    value: Option<Decimal>,\n}\n```\n\nAlternatively, if only the serialization feature is desired (e.g. to keep flexibility while deserialization):\n\n```rust\n# use rust_decimal::Decimal;\n# use rust_decimal_macros::dec;\n# use serde::{Serialize, Deserialize};\n# #[cfg(features = \"serde-with-float\")]\n#[derive(Serialize, Deserialize)]\npub struct FloatExample {\n    #[serde(serialize_with = \"rust_decimal::serde::float::serialize\")]\n    value: Decimal,\n}\n```\n\n### `serde-with-str`\n\nEnable this to access the module for serializing `Decimal` types to a `String`. This can be used in `struct` definitions\nlike so:\n\n```rust\n# use rust_decimal::Decimal;\n# use rust_decimal_macros::dec;\n# use serde::{Serialize, Deserialize};\n# #[cfg(features = \"serde-with-str\")]\n#[derive(Serialize, Deserialize)]\npub struct StrExample {\n    #[serde(with = \"rust_decimal::serde::str\")]\n    value: Decimal,\n}\n```\n\n```rust\n# use rust_decimal::Decimal;\n# use rust_decimal_macros::dec;\n# use serde::{Serialize, Deserialize};\n# #[cfg(features = \"serde-with-str\")]\n#[derive(Serialize, Deserialize)]\npub struct OptionStrExample {\n    #[serde(with = \"rust_decimal::serde::str_option\")]\n    value: Option<Decimal>,\n}\n```\n\nThis feature isn't typically required for serialization however can be useful for deserialization purposes since it does\nnot require\na type hint. Consequently, you can force this for just deserialization by:\n\n```rust\n# use rust_decimal::Decimal;\n# use rust_decimal_macros::dec;\n# use serde::{Serialize, Deserialize};\n# #[cfg(features = \"serde-with-str\")]\n#[derive(Serialize, Deserialize)]\npub struct StrExample {\n    #[serde(deserialize_with = \"rust_decimal::serde::str::deserialize\")]\n    value: Decimal,\n}\n```\n\n### `serde-with-arbitrary-precision`\n\nEnable this to access the module for deserializing `Decimal` types using the `serde_json/arbitrary_precision` feature.\nThis can be used in `struct` definitions like so:\n\n```rust\n# use rust_decimal::Decimal;\n# use rust_decimal_macros::dec;\n# use serde::{Serialize, Deserialize};\n# #[cfg(features = \"serde-with-arbitrary-precision\")]\n#[derive(Serialize, Deserialize)]\npub struct ArbitraryExample {\n    #[serde(with = \"rust_decimal::serde::arbitrary_precision\")]\n    value: Decimal,\n}\n```\n\n```rust\n# use rust_decimal::Decimal;\n# use rust_decimal_macros::dec;\n# use serde::{Serialize, Deserialize};\n# #[cfg(features = \"serde-with-arbitrary-precision\")]\n#[derive(Serialize, Deserialize)]\npub struct OptionArbitraryExample {\n    #[serde(with = \"rust_decimal::serde::arbitrary_precision_option\")]\n    value: Option<Decimal>,\n}\n```\n\nAn unexpected consequence of this feature is that it will serialize as a float like number. To prevent this, you can\ntarget the struct to only deserialize with the `arbitrary_precision` feature:\n\n```rust\n# use rust_decimal::Decimal;\n# use rust_decimal_macros::dec;\n# use serde::{Serialize, Deserialize};\n# #[cfg(features = \"serde-with-arbitrary-precision\")]\n#[derive(Serialize, Deserialize)]\npub struct ArbitraryExample {\n    #[serde(deserialize_with = \"rust_decimal::serde::arbitrary_precision::deserialize\")]\n    value: Decimal,\n}\n```\n\nThis will ensure that serialization still occurs as a string.\n\nPlease see the `examples` directory for more information regarding `serde_json` scenarios.\n\n### `std`\n\nEnable `std` library support. This is enabled by default, however in the future will be opt in. For now, to\nsupport `no_std`\nlibraries, this crate can be compiled with `--no-default-features`.\n\n## Building\n\nPlease refer to the [Build document](https://github.com/paupino/rust-decimal/blob/master/BUILD.md) for more information on building and testing Rust Decimal.\n\n## Minimum Rust Compiler Version\n\nThe current _minimum_ compiler version is `1.67.1` which was released on `2023-02-09`.\n\nThis library maintains support for rust compiler versions that are 4 minor versions away from the current stable rust\ncompiler version.\nFor example, if the current stable compiler version is `1.50.0` then we will guarantee support up to and\nincluding `1.46.0`.\nOf note, we will only update the minimum supported version if and when required.\n\n## Comparison to other Decimal implementations\n\nDuring the development of this library, there were various design decisions made to ensure that decimal calculations\nwould\nbe quick, accurate and efficient. Some decisions, however, put limitations on what this library can do and ultimately\nwhat\nit is suitable for. One such decision was the structure of the internal decimal representation.\n\nThis library uses a mantissa of 96 bits made up of three 32-bit unsigned integers with a fourth 32-bit unsigned integer\nto represent the scale/sign\n(similar to the C and .NET Decimal implementations).\nThis structure allows us to make use of algorithmic optimizations to implement basic arithmetic; ultimately this gives\nus the ability\nto squeeze out performance and make it one of the fastest implementations available. The downside of this approach\nhowever is that\nthe maximum number of significant digits that can be represented is roughly 28 base-10 digits (29 in some cases).\n\nWhile this constraint is not an issue for many applications (e.g. when dealing with money), some applications may\nrequire a higher number of significant digits to be represented. Fortunately,\nthere are alternative implementations that may be worth investigating, such as:\n\n* [bigdecimal](https://crates.io/crates/bigdecimal)\n* [decimal-rs](https://crates.io/crates/decimal-rs)\n\nIf you have further questions about the suitability of this library for your project, then feel free to either start a\n[discussion](https://github.com/paupino/rust-decimal/discussions) or open\nan [issue](https://github.com/paupino/rust-decimal/issues) and we'll\ndo our best to help.\n",
  "sourcePath": "dnd-tracker/src-tauri/target/debug/build/rust_decimal-4f040c63520fc4c9/out/README-lib.md",
  "slug": "use-rust_decimaldecimal",
  "category": "misc"
}